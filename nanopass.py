#!/usr/bin/python3
#
# Copyright 2020 Ledger SAS
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from random import getrandbits as rnd
from binascii import hexlify, unhexlify
import click
import binascii
import json
from typing import Optional, List
import ledgerwallet.client

MAX_NAME_LEN = 32
MAX_PASS_LEN = 32

def str_to_bytes_pad(s, size):
    result = bytearray(s.encode())
    assert len(result) <= size
    while len(result) < size:
        result.append(0)
    return result

class Client:
    def __init__(self, dev):
        """
        Connects to a device.
        :param dev: Instance which implements the communication with the device.
        """
        self.dev = dev
        self.dev.cla = 0x80

    def open_app(self):
        app_name = "nanopass".encode()
        self.dev.cla = 0xe0
        try:
            # Due to current limitation, app won't reply to this APDU and an
            # OSError is thrown as the USB device disconnects. Handle it
            # silently.
            # This needs to be improved
            self.dev.apdu_exchange(0xd8, app_name)
        finally:
            self.dev.cla = 0x80

    def quit_app(self):
        try:
            self.dev.apdu_exchange(0x0c)
        except OSError as e:
            pass

    def get_version(self) -> str:
        """ :return: App version string """
        return self.dev.apdu_exchange(0x01).decode()

    def get_size(self) -> int:
        """
        :return: Number of password entries.
        """
        resp = self.dev.apdu_exchange(0x02)
        assert len(resp) == 4
        return int.from_bytes(resp, 'big')

    def add(self, name: str, password: Optional[str] = None):
        """
        Add a new password.
        :param name: Password name.
        :param password: Password. None if it is generated by the device.
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        if password is not None:
            p1 = 0x00
            password_bytes = str_to_bytes_pad(password, MAX_PASS_LEN)
        else:
            p1 = 0x01
            password_bytes = bytearray()
        self.dev.apdu_exchange(0x03, p1=p1, data=name_bytes + password_bytes)

    def get_name(self, index: int) -> str:
        """
        Retrieve name of a password entry
        :param index: Password entry index
        :return: Name
        """
        r = self.dev.apdu_exchange(0x04, index.to_bytes(4, 'big'))
        while r[-1] == 0:
            r = r[:-1]
        return r.decode()

    def get_names(self) -> List[str]:
        """ :return: List of password names """
        return [self.get_name(i) for i in range(self.get_size())]

    def get_by_name(self, name: str) -> str:
        """
        Retrieve the password with the given name.
        :param name: Password name.
        :return: Password string
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        r = self.dev.apdu_exchange(0x05, name_bytes)
        while r[-1] == 0:
            r = r[:-1]
        return r.decode()

    def get_by_name_internal(self, name: str):
        """
        Retrieve the password on the device with the given name.
        :param name: Password name.
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        self.dev.apdu_exchange(0x0d, name_bytes)

    def delete_by_name(self, name: str):
        """
        Remove a password.
        :param name: Password name.
        """
        name_bytes = str_to_bytes_pad(name, MAX_NAME_LEN)
        self.dev.apdu_exchange(0x06, name_bytes)

    def export(self, encrypt: bool=True) -> List[bytes]:
        """
        Export passwords.
        :param encrypt: True to encrypt passwords during export, False to export
            in plaintext.
        :return: Exported entries.
        """
        p1 = 0x01
        if not encrypt:
            p1 = 0x00
        count = int.from_bytes(self.dev.apdu_exchange(0x07, p1=p1), 'big')
        entries = []
        for i in range(count):
            entries.append(self.dev.apdu_exchange(0x08))
        return entries

    def import_(self, entries: List[bytes], encrypted: bool):
        """
        Import password entries.
        :param entries: Password entries to be imported.
        :param encrypted: True if the entries are encrypted, False if it is in
            plaintext.
        """
        apdu = bytearray(b'\x80\x09\x00\x00\x04' +
            len(entries).to_bytes(4, 'big'))
        p1 = 0x00
        if encrypted:
            p1 = 0x01
        r = self.dev.apdu_exchange(
            0x09, p1=p1, data=len(entries).to_bytes(4, 'big'))
        for p in entries:
            assert len(p) == {True: 16+64+16, False: 64}[encrypted]
            self.dev.apdu_exchange(0x0a, p)

    def clear(self):
        """ Remove all passwords """
        self.dev.apdu_exchange(0x0b)


@click.group()
@click.pass_context
def cli(ctx):
    ctx.ensure_object(dict)
    dev = ledgerwallet.client.LedgerClient()
    ctx.obj['DEV'] = Client(dev)

@cli.command(help="Print installed application version")
@click.pass_context
def version(ctx):
    dev = ctx.obj['DEV']
    print(dev.get_version())

@cli.command(help="Inserts a new password")
@click.argument('name')
@click.pass_context
def insert(ctx, name):
    password = input("Password (empty to generate):")
    if len(password) == 0:
        password = None
    print("Confirm password creation on your device...")
    dev = ctx.obj['DEV']
    dev.add(name, password)

@cli.command(help="Print a stored password")
@click.pass_context
@click.argument('name')
def get(ctx, name):
    dev = ctx.obj['DEV']
    print(dev.get_by_name(name))

@cli.command(help="Print a stored password on the device")
@click.pass_context
@click.argument('name')
def getinternal(ctx, name):
    print("Confirm password display on your device...")
    dev = ctx.obj['DEV']
    print(dev.get_by_name_internal(name))

@cli.command(help="List the names of stored passwords")
@click.pass_context
def list(ctx):
    dev = ctx.obj['DEV']
    names = dev.get_names()
    for name in names:
        print('-', name)

@cli.command(help="Remove a password from the store")
@click.pass_context
@click.argument('name')
def remove(ctx, name):
    dev = ctx.obj['DEV']
    dev.delete_by_name(name)

@cli.command(help="Export passwords to JSON file")
@click.argument('path')
@click.option('--encrypt/--no-encrypt', default=True)
@click.pass_context
def export(ctx, path, encrypt):
    dev = ctx.obj['DEV']
    entries = dev.export(encrypt)
    export = {
        'version': dev.get_version(),
        'encrypted': encrypt,
        'entries': [binascii.hexlify(e).decode() for e in entries]
    }
    with open(path, 'wb') as f:
        f.write(json.dumps(export, indent=2).encode())

@cli.command(name='import', help="Import passwords from JSON file")
@click.argument('path')
@click.pass_context
def import_(ctx, path):
    dev = ctx.obj['DEV']
    data = json.loads(open(path, 'rb').read().decode())
    entries = [bytes.fromhex(e) for e in data['entries']]
    encrypted = data['encrypted']
    dev.import_(entries, encrypted)

@cli.command(help="Clear all passwords")
@click.pass_context
def clear(ctx):
    dev = ctx.obj['DEV']
    dev.clear()

@cli.command(name='open', help="Open application")
@click.pass_context
def open_(ctx):
    dev = ctx.obj['DEV']
    dev.open_app()

@cli.command(help="Quit application")
@click.pass_context
def quit(ctx):
    dev = ctx.obj['DEV']
    dev.quit_app()


if __name__ == '__main__':
    cli()
